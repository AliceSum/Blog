{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "_mEF05xtbHwp"
      },
      "source": [
        "## makemore: part 5 (building a WaveNet)\n",
        "\n",
        "[DeepMind blog post from 2016](https://www.deepmind.com/blog/wavenet-a-generative-model-for-raw-audio)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "7lDFibCgbHwr"
      },
      "outputs": [],
      "source": [
        "import torch\n",
        "import torch.nn.functional as F\n",
        "import matplotlib.pyplot as plt # for making figures\n",
        "%matplotlib inline"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "htdQCnUPbhS9",
        "outputId": "eb9aff33-302e-40ab-8952-9f49dd6a9f35"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "--2022-12-24 10:40:48--  https://raw.githubusercontent.com/karpathy/makemore/master/names.txt\n",
            "Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.111.133, 185.199.108.133, 185.199.109.133, ...\n",
            "Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.111.133|:443... connected.\n",
            "HTTP request sent, awaiting response... 200 OK\n",
            "Length: 228145 (223K) [text/plain]\n",
            "Saving to: ‘names.txt.1’\n",
            "\n",
            "names.txt.1         100%[===================>] 222.80K  --.-KB/s    in 0.005s  \n",
            "\n",
            "2022-12-24 10:40:48 (48.1 MB/s) - ‘names.txt.1’ saved [228145/228145]\n",
            "\n"
          ]
        }
      ],
      "source": [
        "# download the names.txt file from github\n",
        "!wget https://raw.githubusercontent.com/karpathy/makemore/master/names.txt"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "ylW9Ir3GbHws",
        "outputId": "3332080a-c1d1-4de6-91fa-0032625091bc"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "32033\n",
            "15\n",
            "['emma', 'olivia', 'ava', 'isabella', 'sophia', 'charlotte', 'mia', 'amelia']\n"
          ]
        }
      ],
      "source": [
        "# read in all the words\n",
        "words = open('names.txt', 'r').read().splitlines()\n",
        "print(len(words))\n",
        "print(max(len(w) for w in words))\n",
        "print(words[:8])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "GPwi-_rEbHwt",
        "outputId": "d30d9bf4-f7b0-4a22-c82b-41054f131157"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "{1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e', 6: 'f', 7: 'g', 8: 'h', 9: 'i', 10: 'j', 11: 'k', 12: 'l', 13: 'm', 14: 'n', 15: 'o', 16: 'p', 17: 'q', 18: 'r', 19: 's', 20: 't', 21: 'u', 22: 'v', 23: 'w', 24: 'x', 25: 'y', 26: 'z', 0: '.'}\n",
            "27\n"
          ]
        }
      ],
      "source": [
        "# build the vocabulary of characters and mappings to/from integers\n",
        "chars = sorted(list(set(''.join(words))))\n",
        "stoi = {s:i+1 for i,s in enumerate(chars)}\n",
        "stoi['.'] = 0\n",
        "itos = {i:s for s,i in stoi.items()}\n",
        "vocab_size = len(itos)\n",
        "print(itos)\n",
        "print(vocab_size)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "j8JdduA3bHwu"
      },
      "outputs": [],
      "source": [
        "# shuffle up the words\n",
        "import random\n",
        "random.seed(42)\n",
        "random.shuffle(words)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "kcrfsUG_bHwu",
        "outputId": "4b3e204a-6747-41d5-ce19-f279e6f4c3a1"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "torch.Size([182625, 8]) torch.Size([182625])\n",
            "torch.Size([22655, 8]) torch.Size([22655])\n",
            "torch.Size([22866, 8]) torch.Size([22866])\n"
          ]
        }
      ],
      "source": [
        "# build the dataset\n",
        "block_size = 8 # context length: how many characters do we take to predict the next one?\n",
        "\n",
        "def build_dataset(words):  \n",
        "  X, Y = [], []\n",
        "  \n",
        "  for w in words:\n",
        "    # Since starting int is 0, we have the starting int,0 here.\n",
        "    context = [0] * block_size\n",
        "    for ch in w + '.':\n",
        "      ix = stoi[ch]\n",
        "      X.append(context)\n",
        "      Y.append(ix)\n",
        "      context = context[1:] + [ix] # crop and append\n",
        "\n",
        "  X = torch.tensor(X)\n",
        "  Y = torch.tensor(Y)\n",
        "  print(X.shape, Y.shape)\n",
        "  return X, Y\n",
        "\n",
        "n1 = int(0.8*len(words))\n",
        "n2 = int(0.9*len(words))\n",
        "Xtr,  Ytr  = build_dataset(words[:n1])     # 80%\n",
        "Xdev, Ydev = build_dataset(words[n1:n2])   # 10%\n",
        "Xte,  Yte  = build_dataset(words[n2:])     # 10%"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "9aFDMks6bHwv",
        "outputId": "40fae0d9-1d2f-470d-e82d-a7a2fd9d6118"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "........ --> y\n",
            ".......y --> u\n",
            "......yu --> h\n",
            ".....yuh --> e\n",
            "....yuhe --> n\n",
            "...yuhen --> g\n",
            "..yuheng --> .\n",
            "........ --> d\n",
            ".......d --> i\n",
            "......di --> o\n",
            ".....dio --> n\n",
            "....dion --> d\n",
            "...diond --> r\n",
            "..diondr --> e\n",
            ".diondre --> .\n",
            "........ --> x\n",
            ".......x --> a\n",
            "......xa --> v\n",
            ".....xav --> i\n",
            "....xavi --> e\n"
          ]
        }
      ],
      "source": [
        "for x,y in zip(Xtr[:20], Ytr[:20]):\n",
        "  print(''.join(itos[ix.item()] for ix in x), '-->', itos[y.item()])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "MgbP_-Uzomlw"
      },
      "outputs": [],
      "source": [
        "import math\n",
        "import torch.nn as nn"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "-goFZmrabHww"
      },
      "outputs": [],
      "source": [
        "# Near copy paste of the layers we have developed in Part 3\n",
        "\n",
        "# -----------------------------------------------------------------------------------------------\n",
        "class Linear:\n",
        "  \n",
        "  def __init__(self, fan_in, fan_out, bias=True):\n",
        "    self.weight = torch.randn((fan_in, fan_out)) / fan_in**0.5 # note: kaiming init\n",
        "    self.bias = torch.zeros(fan_out) if bias else None\n",
        "  \n",
        "  def __call__(self, x):\n",
        "    self.out = x @ self.weight\n",
        "    if self.bias is not None:\n",
        "      self.out += self.bias\n",
        "    return self.out\n",
        "  \n",
        "  def parameters(self):\n",
        "    return [self.weight] + ([] if self.bias is None else [self.bias])\n",
        "\n",
        "# -----------------------------------------------------------------------------------------------\n",
        "class BatchNorm1d:\n",
        "  \n",
        "  def __init__(self, dim, eps=1e-5, momentum=0.1):\n",
        "    self.eps = eps\n",
        "    self.momentum = momentum\n",
        "    self.training = True\n",
        "    # parameters (trained with backprop)\n",
        "    self.gamma = torch.ones(dim)\n",
        "    self.beta = torch.zeros(dim)\n",
        "    # buffers (trained with a running 'momentum update')\n",
        "    self.running_mean = torch.zeros(dim)\n",
        "    self.running_var = torch.ones(dim)\n",
        "  \n",
        "  def __call__(self, x):\n",
        "    # calculate the forward pass\n",
        "    if self.training:\n",
        "      if x.ndim == 2:\n",
        "        dim = 0\n",
        "      elif x.ndim == 3:\n",
        "        dim = (0,1)\n",
        "      xmean = x.mean(dim, keepdim=True) # batch mean\n",
        "      xvar = x.var(dim, keepdim=True) # batch variance\n",
        "    else:\n",
        "      xmean = self.running_mean\n",
        "      xvar = self.running_var\n",
        "    xhat = (x - xmean) / torch.sqrt(xvar + self.eps) # normalize to unit variance\n",
        "    self.out = self.gamma * xhat + self.beta\n",
        "    # update the buffers\n",
        "    if self.training:\n",
        "      with torch.no_grad():\n",
        "        self.running_mean = (1 - self.momentum) * self.running_mean + self.momentum * xmean\n",
        "        self.running_var = (1 - self.momentum) * self.running_var + self.momentum * xvar\n",
        "    return self.out\n",
        "  \n",
        "  def parameters(self):\n",
        "    return [self.gamma, self.beta]\n",
        "\n",
        "# -----------------------------------------------------------------------------------------------\n",
        "class Tanh:\n",
        "  def __call__(self, x):\n",
        "    self.out = torch.tanh(x)\n",
        "    return self.out\n",
        "  def parameters(self):\n",
        "    return []\n",
        "\n",
        "# -----------------------------------------------------------------------------------------------\n",
        "class NewGELU:\n",
        "  #cite: https://github.com/karpathy/makemore/blob/master/makemore.py\n",
        "  def __call__(self, x):\n",
        "      return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n",
        "  def parameters(self):\n",
        "      return []\n",
        "# -----------------------------------------------------------------------------------------------\n",
        "class RELU:\n",
        "  def __call__(self, x):\n",
        "      m = nn.ReLU(0.1)\n",
        "      return m(x)\n",
        "      #return torch.where(x <0., torch.zeros_like(x), x)\n",
        "  def parameters(self):\n",
        "      return []\n",
        "\n",
        "# -----------------------------------------------------------------------------------------------\n",
        "class LeakyRELU:\n",
        "  def __call__(self, x):\n",
        "      m = nn.LeakyReLU(0.1)\n",
        "      return m(x)\n",
        "      #return torch.where(x <0., torch.zeros_like(x), x)\n",
        "  def parameters(self):\n",
        "      return []\n",
        "\n",
        "# -----------------------------------------------------------------------------------------------\n",
        "\n",
        "class Embedding:\n",
        "  \n",
        "  def __init__(self, num_embeddings, embedding_dim):\n",
        "    self.weight = torch.randn((num_embeddings, embedding_dim))\n",
        "    \n",
        "  def __call__(self, IX):\n",
        "    self.out = self.weight[IX]\n",
        "    return self.out\n",
        "  \n",
        "  def parameters(self):\n",
        "    return [self.weight]\n",
        "\n",
        "# -----------------------------------------------------------------------------------------------\n",
        "class FlattenConsecutive:\n",
        "  #FlattenConsecutive(8), Linear(n_embd * 8, n_hidden, bias=False)\n",
        "  def __init__(self, n):\n",
        "    self.n = n\n",
        "    \n",
        "  def __call__(self, x):\n",
        "    B, T, C = x.shape\n",
        "    x = x.view(B, T//self.n, C*self.n)\n",
        "    if x.shape[1] == 1:\n",
        "      x = x.squeeze(1)\n",
        "    self.out = x\n",
        "    return self.out\n",
        "  \n",
        "  def parameters(self):\n",
        "    return []\n",
        "\n",
        "# -----------------------------------------------------------------------------------------------\n",
        "class Sequential:\n",
        "  \n",
        "  def __init__(self, layers):\n",
        "    self.layers = layers\n",
        "  \n",
        "  def __call__(self, x):\n",
        "    for layer in self.layers:\n",
        "      x = layer(x)\n",
        "    self.out = x\n",
        "    return self.out\n",
        "  \n",
        "  def parameters(self):\n",
        "    # get parameters of all layers and stretch them out into one list\n",
        "    return [p for layer in self.layers for p in layer.parameters()]\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "v01gpFOSbHwx"
      },
      "outputs": [],
      "source": [
        "torch.manual_seed(42); # seed rng for reproducibility"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "vHMDMtvpbHwx",
        "outputId": "084c1685-7a57-4d75-fade-d646b9dfe0ff"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "78843\n"
          ]
        }
      ],
      "source": [
        "# original network\n",
        "# n_embd = 10 # the dimensionality of the character embedding vectors\n",
        "# n_hidden = 300 # the number of neurons in the hidden layer of the MLP\n",
        "# model = Sequential([\n",
        "#   Embedding(vocab_size, n_embd),\n",
        "#   FlattenConsecutive(8), Linear(n_embd * 8, n_hidden, bias=False), BatchNorm1d(n_hidden), Tanh(),\n",
        "#   Linear(n_hidden, vocab_size),\n",
        "# ])\n",
        "\n",
        "# hierarchical network\n",
        "n_embd = 32 # the dimensionality of the character embedding vectors\n",
        "n_hidden = 128 # the number of neurons in the hidden layer of the MLP\n",
        "model = Sequential([\n",
        "  Embedding(vocab_size, n_embd),\n",
        "  FlattenConsecutive(2), Linear(n_embd * 2, n_hidden, bias=False), BatchNorm1d(n_hidden), Tanh(),\n",
        "  FlattenConsecutive(2), Linear(n_hidden*2, n_hidden, bias=False), BatchNorm1d(n_hidden), Tanh(),\n",
        "  FlattenConsecutive(2), Linear(n_hidden*2, n_hidden, bias=False), BatchNorm1d(n_hidden), Tanh(),\n",
        "  Linear(n_hidden, vocab_size),\n",
        "])\n",
        "\n",
        "# parameter init\n",
        "with torch.no_grad():\n",
        "  model.layers[-1].weight *= 0.1 # last layer make less confident\n",
        "\n",
        "parameters = model.parameters()\n",
        "print(sum(p.nelement() for p in parameters)) # number of parameters in total\n",
        "for p in parameters:\n",
        "  p.requires_grad = True"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "Sh9SEATabHwy",
        "outputId": "289700c5-97c7-4284-bc7d-2caa08ba4a0f"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "      0/ 200000: 3.2889\n",
            "  10000/ 200000: 2.1119\n",
            "  20000/ 200000: 2.2623\n",
            "  30000/ 200000: 2.0563\n",
            "  40000/ 200000: 1.8632\n",
            "  50000/ 200000: 1.6557\n",
            "  60000/ 200000: 2.0003\n",
            "  70000/ 200000: 2.0606\n",
            "  80000/ 200000: 2.0176\n",
            "  90000/ 200000: 1.6827\n",
            " 100000/ 200000: 1.6439\n",
            " 110000/ 200000: 2.3658\n",
            " 120000/ 200000: 1.6008\n",
            " 130000/ 200000: 1.8810\n",
            " 140000/ 200000: 2.0688\n",
            " 150000/ 200000: 1.9981\n",
            " 160000/ 200000: 1.8367\n",
            " 170000/ 200000: 1.9328\n",
            " 180000/ 200000: 1.8882\n",
            " 190000/ 200000: 1.7317\n"
          ]
        }
      ],
      "source": [
        "# same optimization as last time\n",
        "max_steps = 200000\n",
        "batch_size = 32\n",
        "lossi = []\n",
        "\n",
        "for i in range(max_steps):\n",
        "  \n",
        "  # minibatch construct\n",
        "  ix = torch.randint(0, Xtr.shape[0], (batch_size,))\n",
        "  Xb, Yb = Xtr[ix], Ytr[ix] # batch X,Y\n",
        "  \n",
        "  # forward pass\n",
        "  logits = model(Xb)\n",
        "  loss = F.cross_entropy(logits, Yb) # loss function\n",
        "  \n",
        "  # backward pass\n",
        "  for p in parameters:\n",
        "    p.grad = None\n",
        "  loss.backward()\n",
        "  \n",
        "  # update: simple SGD\n",
        "  lr = 0.1 if i < 150000 else 0.01 # step learning rate decay\n",
        "  for p in parameters:\n",
        "    p.data += -lr * p.grad\n",
        "\n",
        "  # track stats\n",
        "  if i % 10000 == 0: # print every once in a while\n",
        "    print(f'{i:7d}/{max_steps:7d}: {loss.item():.4f}')\n",
        "  lossi.append(loss.log10().item())\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 282
        },
        "id": "XrOSTEFzbHwz",
        "outputId": "d96dc554-f3b0-4ea4-e237-21e9a3ba5b8d"
      },
      "outputs": [
        {
          "data": {
            "text/plain": [
              "[<matplotlib.lines.Line2D at 0x7fcc012d5a30>]"
            ]
          },
          "execution_count": 13,
          "metadata": {},
          "output_type": "execute_result"
        },
        {
          "data": {
            "image/png": "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\n",
            "text/plain": [
              "<Figure size 432x288 with 1 Axes>"
            ]
          },
          "metadata": {},
          "output_type": "display_data"
        }
      ],
      "source": [
        "plt.plot(torch.tensor(lossi).view(-1, 1000).mean(1))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "ehknU7xtbHwz"
      },
      "outputs": [],
      "source": [
        "# put layers into eval mode (needed for batchnorm especially)\n",
        "for layer in model.layers:\n",
        "  layer.training = False"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "5W1wFpKubHwz",
        "outputId": "fc162447-d56e-4751-b42d-89d6aa8e3c9a"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "train 1.76247239112854\n",
            "val 1.992129921913147\n"
          ]
        }
      ],
      "source": [
        "# evaluate the loss\n",
        "@torch.no_grad() # this decorator disables gradient tracking inside pytorch\n",
        "def split_loss(split):\n",
        "  x,y = {\n",
        "    'train': (Xtr, Ytr),\n",
        "    'val': (Xdev, Ydev),\n",
        "    'test': (Xte, Yte),\n",
        "  }[split]\n",
        "  logits = model(x)\n",
        "  loss = F.cross_entropy(logits, y)\n",
        "  print(split, loss.item())\n",
        "\n",
        "split_loss('train')\n",
        "split_loss('val')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "1TgwUzS6xmav",
        "outputId": "f131b9da-de4d-4a20-876b-13121bfd415b"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "78843\n"
          ]
        }
      ],
      "source": [
        "n_embd = 32 # the dimensionality of the character embedding vectors\n",
        "n_hidden = 128 # the number of neurons in the hidden layer of the MLP\n",
        "model = Sequential([\n",
        "  Embedding(vocab_size, n_embd),\n",
        "  FlattenConsecutive(2), Linear(n_embd * 2, n_hidden, bias=False), BatchNorm1d(n_hidden), RELU(),\n",
        "  FlattenConsecutive(2), Linear(n_hidden*2, n_hidden, bias=False), BatchNorm1d(n_hidden), RELU(),\n",
        "  FlattenConsecutive(2), Linear(n_hidden*2, n_hidden, bias=False), BatchNorm1d(n_hidden), RELU(),\n",
        "  Linear(n_hidden, vocab_size),\n",
        "])\n",
        "\n",
        "# parameter init\n",
        "with torch.no_grad():\n",
        "  model.layers[-1].weight *= 0.1 # last layer make less confident\n",
        "\n",
        "parameters = model.parameters()\n",
        "print(sum(p.nelement() for p in parameters)) # number of parameters in total\n",
        "for p in parameters:\n",
        "  p.requires_grad = True"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "BRTakM0q5BBb",
        "outputId": "96549d85-63ad-44e9-d241-6367f8384ba5"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "      0/ 200000: 3.2679\n",
            "  10000/ 200000: 2.2773\n",
            "  20000/ 200000: 2.4319\n",
            "  30000/ 200000: 1.9070\n",
            "  40000/ 200000: 1.8652\n",
            "  50000/ 200000: 1.7508\n",
            "  60000/ 200000: 1.6275\n",
            "  70000/ 200000: 2.3390\n",
            "  80000/ 200000: 1.9422\n",
            "  90000/ 200000: 1.8612\n",
            " 100000/ 200000: 1.8918\n",
            " 110000/ 200000: 2.0650\n",
            " 120000/ 200000: 2.1860\n",
            " 130000/ 200000: 1.9055\n",
            " 140000/ 200000: 1.9330\n",
            " 150000/ 200000: 1.9261\n",
            " 160000/ 200000: 1.7498\n",
            " 170000/ 200000: 2.1826\n",
            " 180000/ 200000: 1.6916\n",
            " 190000/ 200000: 1.7595\n"
          ]
        }
      ],
      "source": [
        "# same optimization as last time\n",
        "max_steps = 200000\n",
        "batch_size = 32\n",
        "lossi = []\n",
        "\n",
        "for i in range(max_steps):\n",
        "  \n",
        "  # minibatch construct\n",
        "  ix = torch.randint(0, Xtr.shape[0], (batch_size,))\n",
        "  Xb, Yb = Xtr[ix], Ytr[ix] # batch X,Y\n",
        "  \n",
        "  # forward pass\n",
        "  logits = model(Xb)\n",
        "  loss = F.cross_entropy(logits, Yb) # loss function\n",
        "  \n",
        "  # backward pass\n",
        "  for p in parameters:\n",
        "    p.grad = None\n",
        "  loss.backward()\n",
        "  \n",
        "  # update: simple SGD\n",
        "  lr = 0.1 if i < 150000 else 0.01 # step learning rate decay\n",
        "  for p in parameters:\n",
        "    p.data += -lr * p.grad\n",
        "\n",
        "  # track stats\n",
        "  if i % 10000 == 0: # print every once in a while\n",
        "    print(f'{i:7d}/{max_steps:7d}: {loss.item():.4f}')\n",
        "  lossi.append(loss.log10().item())\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "1lZWsRdJx1CL"
      },
      "outputs": [],
      "source": [
        "plt.plot(torch.tensor(lossi).view(-1, 1000).mean(1))\n",
        "# put layers into eval mode (needed for batchnorm especially)\n",
        "for layer in model.layers:\n",
        "  layer.training = False\n",
        "\n",
        "# evaluate the loss\n",
        "@torch.no_grad() # this decorator disables gradient tracking inside pytorch\n",
        "def split_loss(split):\n",
        "  x,y = {\n",
        "    'train': (Xtr, Ytr),\n",
        "    'val': (Xdev, Ydev),\n",
        "    'test': (Xte, Yte),\n",
        "  }[split]\n",
        "  logits = model(x)\n",
        "  loss = F.cross_entropy(logits, y)\n",
        "  print(split, loss.item())\n",
        "\n",
        "split_loss('train')\n",
        "split_loss('val')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "tMo4aBr_RR3C"
      },
      "outputs": [],
      "source": [
        "# put layers into eval mode (needed for batchnorm especially)\n",
        "for layer in model.layers:\n",
        "  layer.training = False"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "T5vvrVjRRVgN"
      },
      "outputs": [],
      "source": [
        "# evaluate the loss\n",
        "@torch.no_grad() # this decorator disables gradient tracking inside pytorch\n",
        "def split_loss(split):\n",
        "  x,y = {\n",
        "    'train': (Xtr, Ytr),\n",
        "    'val': (Xdev, Ydev),\n",
        "    'test': (Xte, Yte),\n",
        "  }[split]\n",
        "  logits = model(x)\n",
        "  loss = F.cross_entropy(logits, y)\n",
        "  print(split, loss.item())\n",
        "\n",
        "split_loss('train')\n",
        "split_loss('val')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "WQMocINHx7LH"
      },
      "outputs": [],
      "source": [
        "n_embd = 32 # the dimensionality of the character embedding vectors\n",
        "n_hidden = 128 # the number of neurons in the hidden layer of the MLP\n",
        "model = Sequential([\n",
        "  Embedding(vocab_size, n_embd),\n",
        "  FlattenConsecutive(2), Linear(n_embd * 2, n_hidden, bias=False), BatchNorm1d(n_hidden), NewGELU(),\n",
        "  FlattenConsecutive(2), Linear(n_hidden*2, n_hidden, bias=False), BatchNorm1d(n_hidden), NewGELU(),\n",
        "  FlattenConsecutive(2), Linear(n_hidden*2, n_hidden, bias=False), BatchNorm1d(n_hidden), NewGELU(),\n",
        "  Linear(n_hidden, vocab_size)\n",
        "])\n",
        "\n",
        "# parameter init\n",
        "with torch.no_grad():\n",
        "  model.layers[-1].weight *= 0.1 # last layer make less confident\n",
        "\n",
        "parameters = model.parameters()\n",
        "print(sum(p.nelement() for p in parameters)) # number of parameters in total\n",
        "for p in parameters:\n",
        "  p.requires_grad = True"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "ZwOsOw1Q9TtW",
        "outputId": "afae0e61-b65e-4efb-e9c1-05e884babf0a"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "      0/ 200000: 3.2810\n",
            "  10000/ 200000: 2.3747\n",
            "  20000/ 200000: 1.8684\n",
            "  30000/ 200000: 1.8986\n",
            "  40000/ 200000: 1.7256\n",
            "  50000/ 200000: 1.8924\n",
            "  60000/ 200000: 1.7530\n",
            "  70000/ 200000: 1.8827\n",
            "  80000/ 200000: 1.9257\n",
            "  90000/ 200000: 2.0728\n",
            " 100000/ 200000: 1.9873\n",
            " 110000/ 200000: 1.6364\n",
            " 120000/ 200000: 1.6870\n",
            " 130000/ 200000: 1.4691\n",
            " 140000/ 200000: 2.0933\n",
            " 150000/ 200000: 1.9816\n",
            " 160000/ 200000: 1.2619\n",
            " 170000/ 200000: 1.8261\n",
            " 180000/ 200000: 1.8023\n",
            " 190000/ 200000: 1.9140\n"
          ]
        }
      ],
      "source": [
        "# same optimization as last time\n",
        "max_steps = 200000\n",
        "batch_size = 32\n",
        "lossi = []\n",
        "\n",
        "for i in range(max_steps):\n",
        "  \n",
        "  # minibatch construct\n",
        "  ix = torch.randint(0, Xtr.shape[0], (batch_size,))\n",
        "  Xb, Yb = Xtr[ix], Ytr[ix] # batch X,Y\n",
        "  \n",
        "  # forward pass\n",
        "  logits = model(Xb)\n",
        "  loss = F.cross_entropy(logits, Yb) # loss function\n",
        "  \n",
        "  # backward pass\n",
        "  for p in parameters:\n",
        "    p.grad = None\n",
        "  loss.backward()\n",
        "  \n",
        "  # update: simple SGD\n",
        "  lr = 0.1 if i < 150000 else 0.01 # step learning rate decay\n",
        "  for p in parameters:\n",
        "    p.data += -lr * p.grad\n",
        "\n",
        "  # track stats\n",
        "  if i % 10000 == 0: # print every once in a while\n",
        "    print(f'{i:7d}/{max_steps:7d}: {loss.item():.4f}')\n",
        "  lossi.append(loss.log10().item())\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 282
        },
        "id": "cdo3THeMSv0Q",
        "outputId": "e43d579c-c274-4ac8-eab6-bbb930ce0c5b"
      },
      "outputs": [
        {
          "data": {
            "text/plain": [
              "[<matplotlib.lines.Line2D at 0x7fcc00d16550>]"
            ]
          },
          "execution_count": 23,
          "metadata": {},
          "output_type": "execute_result"
        },
        {
          "data": {
            "image/png": "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\n",
            "text/plain": [
              "<Figure size 432x288 with 1 Axes>"
            ]
          },
          "metadata": {},
          "output_type": "display_data"
        }
      ],
      "source": [
        "plt.plot(torch.tensor(lossi).view(-1, 1000).mean(1))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "AZ5g75AAx8i8",
        "outputId": "89a5bfdd-f1b7-4319-b25b-c53650ce6464"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "train 1.7242008447647095\n",
            "val 2.0082082748413086\n"
          ]
        }
      ],
      "source": [
        "# put layers into eval mode (needed for batchnorm especially)\n",
        "for layer in model.layers:\n",
        "  layer.training = False\n",
        "\n",
        "# evaluate the loss\n",
        "@torch.no_grad() # this decorator disables gradient tracking inside pytorch\n",
        "def split_loss(split):\n",
        "  x,y = {\n",
        "    'train': (Xtr, Ytr),\n",
        "    'val': (Xdev, Ydev),\n",
        "    'test': (Xte, Yte),\n",
        "  }[split]\n",
        "  logits = model(x)\n",
        "  loss = F.cross_entropy(logits, y)\n",
        "  print(split, loss.item())\n",
        "\n",
        "split_loss('train')\n",
        "split_loss('val')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "zh4rghhgRcpY",
        "outputId": "c2883af1-df19-4232-943d-2ceaab03d0c9"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "78843\n"
          ]
        }
      ],
      "source": [
        "n_embd = 32 # the dimensionality of the character embedding vectors\n",
        "n_hidden = 128 # the number of neurons in the hidden layer of the MLP\n",
        "model = Sequential([\n",
        "  Embedding(vocab_size, n_embd),\n",
        "  FlattenConsecutive(2), Linear(n_embd * 2, n_hidden, bias=False), BatchNorm1d(n_hidden), LeakyRELU(),\n",
        "  FlattenConsecutive(2), Linear(n_hidden*2, n_hidden, bias=False), BatchNorm1d(n_hidden), LeakyRELU(),\n",
        "  FlattenConsecutive(2), Linear(n_hidden*2, n_hidden, bias=False), BatchNorm1d(n_hidden), LeakyRELU(),\n",
        "  Linear(n_hidden, vocab_size)\n",
        "])\n",
        "\n",
        "# parameter init\n",
        "with torch.no_grad():\n",
        "  model.layers[-1].weight *= 0.1 # last layer make less confident\n",
        "\n",
        "parameters = model.parameters()\n",
        "print(sum(p.nelement() for p in parameters)) # number of parameters in total\n",
        "for p in parameters:\n",
        "  p.requires_grad = True"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "KxRryb1WRwpr",
        "outputId": "666e2b27-6419-4510-e3c8-bfb64f405dbd"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "      0/ 200000: 3.3223\n",
            "  10000/ 200000: 2.1305\n",
            "  20000/ 200000: 2.0733\n",
            "  30000/ 200000: 1.9686\n",
            "  40000/ 200000: 1.9352\n",
            "  50000/ 200000: 2.2490\n",
            "  60000/ 200000: 1.7100\n",
            "  70000/ 200000: 2.0447\n",
            "  80000/ 200000: 1.6909\n",
            "  90000/ 200000: 1.9578\n",
            " 100000/ 200000: 2.3184\n",
            " 110000/ 200000: 1.6809\n",
            " 120000/ 200000: 1.9447\n",
            " 130000/ 200000: 1.8925\n",
            " 140000/ 200000: 1.5960\n",
            " 150000/ 200000: 1.9907\n",
            " 160000/ 200000: 1.8722\n",
            " 170000/ 200000: 1.6583\n",
            " 180000/ 200000: 1.9966\n",
            " 190000/ 200000: 1.8426\n"
          ]
        }
      ],
      "source": [
        "# same optimization as last time\n",
        "max_steps = 200000\n",
        "batch_size = 32\n",
        "lossi = []\n",
        "\n",
        "for i in range(max_steps):\n",
        "  \n",
        "  # minibatch construct\n",
        "  ix = torch.randint(0, Xtr.shape[0], (batch_size,))\n",
        "  Xb, Yb = Xtr[ix], Ytr[ix] # batch X,Y\n",
        "  \n",
        "  # forward pass\n",
        "  logits = model(Xb)\n",
        "  loss = F.cross_entropy(logits, Yb) # loss function\n",
        "  \n",
        "  # backward pass\n",
        "  for p in parameters:\n",
        "    p.grad = None\n",
        "  loss.backward()\n",
        "  \n",
        "  # update: simple SGD\n",
        "  lr = 0.1 if i < 150000 else 0.01 # step learning rate decay\n",
        "  for p in parameters:\n",
        "    p.data += -lr * p.grad\n",
        "\n",
        "  # track stats\n",
        "  if i % 10000 == 0: # print every once in a while\n",
        "    print(f'{i:7d}/{max_steps:7d}: {loss.item():.4f}')\n",
        "  lossi.append(loss.log10().item())\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 282
        },
        "id": "nzG6NFo5RzBg",
        "outputId": "5aed259e-b401-4e8d-ac3f-b38c33b50496"
      },
      "outputs": [
        {
          "data": {
            "text/plain": [
              "[<matplotlib.lines.Line2D at 0x7fcc00cf48e0>]"
            ]
          },
          "execution_count": 27,
          "metadata": {},
          "output_type": "execute_result"
        },
        {
          "data": {
            "image/png": "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\n",
            "text/plain": [
              "<Figure size 432x288 with 1 Axes>"
            ]
          },
          "metadata": {},
          "output_type": "display_data"
        }
      ],
      "source": [
        "plt.plot(torch.tensor(lossi).view(-1, 1000).mean(1))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "a1G14ZILR01l"
      },
      "outputs": [],
      "source": [
        "# put layers into eval mode (needed for batchnorm especially)\n",
        "for layer in model.layers:\n",
        "  layer.training = False"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "gL6Wx3MIR5Bu",
        "outputId": "19394ad4-cf85-4ccd-f0ab-cff69c358c5d"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "train 1.7780346870422363\n",
            "val 1.9922443628311157\n"
          ]
        }
      ],
      "source": [
        "# evaluate the loss\n",
        "@torch.no_grad() # this decorator disables gradient tracking inside pytorch\n",
        "def split_loss(split):\n",
        "  x,y = {\n",
        "    'train': (Xtr, Ytr),\n",
        "    'val': (Xdev, Ydev),\n",
        "    'test': (Xte, Yte),\n",
        "  }[split]\n",
        "  logits = model(x)\n",
        "  loss = F.cross_entropy(logits, y)\n",
        "  print(split, loss.item())\n",
        "\n",
        "split_loss('train')\n",
        "split_loss('val')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "2YI4u5dUR952",
        "outputId": "206e5fc8-c6b7-42d1-d64e-16b811ed6470"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "78843\n"
          ]
        }
      ],
      "source": [
        "n_embd = 32 # the dimensionality of the character embedding vectors\n",
        "n_hidden = 128 # the number of neurons in the hidden layer of the MLP\n",
        "model = Sequential([\n",
        "  Embedding(vocab_size, n_embd),\n",
        "  FlattenConsecutive(2), Linear(n_embd * 2, n_hidden, bias=False), BatchNorm1d(n_hidden), LeakyRELU(),\n",
        "  FlattenConsecutive(2), Linear(n_hidden*2, n_hidden, bias=False), BatchNorm1d(n_hidden), LeakyRELU(),\n",
        "  FlattenConsecutive(2), Linear(n_hidden*2, n_hidden, bias=False), BatchNorm1d(n_hidden), LeakyRELU(),\n",
        "  Linear(n_hidden, vocab_size)\n",
        "])\n",
        "\n",
        "# parameter init\n",
        "with torch.no_grad():\n",
        "  model.layers[-1].weight *= 0.1 # last layer make less confident\n",
        "\n",
        "parameters = model.parameters()\n",
        "print(sum(p.nelement() for p in parameters)) # number of parameters in total\n",
        "for p in parameters:\n",
        "  p.requires_grad = True"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true,
          "base_uri": "https://localhost:8080/"
        },
        "id": "ANvlcj_FSESI",
        "outputId": "73944de6-3a96-43d4-f418-7760a0d034ad"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "      0/ 200000: 3.2804\n",
            "  10000/ 200000: 2.3572\n",
            "  20000/ 200000: 1.8440\n",
            "  30000/ 200000: 1.9347\n",
            "  40000/ 200000: 2.2132\n",
            "  50000/ 200000: 2.1905\n",
            "  60000/ 200000: 2.2333\n",
            "  70000/ 200000: 2.0059\n",
            "  80000/ 200000: 2.3401\n",
            "  90000/ 200000: 1.9127\n",
            " 100000/ 200000: 2.2821\n",
            " 110000/ 200000: 1.7435\n",
            " 120000/ 200000: 1.9925\n",
            " 130000/ 200000: 2.0787\n",
            " 140000/ 200000: 1.5694\n",
            " 150000/ 200000: 1.7896\n",
            " 160000/ 200000: 1.7211\n",
            " 170000/ 200000: 1.6352\n",
            " 180000/ 200000: 1.7493\n",
            " 190000/ 200000: 1.6314\n"
          ]
        }
      ],
      "source": [
        "# same optimization as last time\n",
        "max_steps = 200000\n",
        "batch_size = 32\n",
        "lossi = []\n",
        "\n",
        "for i in range(max_steps):\n",
        "  \n",
        "  # minibatch construct\n",
        "  ix = torch.randint(0, Xtr.shape[0], (batch_size,))\n",
        "  Xb, Yb = Xtr[ix], Ytr[ix] # batch X,Y\n",
        "  \n",
        "  # forward pass\n",
        "  logits = model(Xb)\n",
        "  loss = F.cross_entropy(logits, Yb) # loss function\n",
        "  \n",
        "  # backward pass\n",
        "  for p in parameters:\n",
        "    p.grad = None\n",
        "  loss.backward()\n",
        "  \n",
        "  # update: simple SGD\n",
        "  lr = 0.1 if i < 150000 else 0.01 # step learning rate decay\n",
        "  for p in parameters:\n",
        "    p.data += -lr * p.grad\n",
        "\n",
        "  # track stats\n",
        "  if i % 10000 == 0: # print every once in a while\n",
        "    print(f'{i:7d}/{max_steps:7d}: {loss.item():.4f}')\n",
        "  lossi.append(loss.log10().item())\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true
        },
        "id": "l3GNJU7tTBvL",
        "outputId": "04017d69-2d74-4efd-daad-e48b0e93f7b1"
      },
      "outputs": [
        {
          "data": {
            "text/plain": [
              "[<matplotlib.lines.Line2D at 0x7fcc01f11fd0>]"
            ]
          },
          "execution_count": 32,
          "metadata": {},
          "output_type": "execute_result"
        },
        {
          "data": {
            "image/png": "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\n",
            "text/plain": [
              "<Figure size 432x288 with 1 Axes>"
            ]
          },
          "metadata": {},
          "output_type": "display_data"
        }
      ],
      "source": [
        "plt.plot(torch.tensor(lossi).view(-1, 1000).mean(1))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true
        },
        "id": "Fq3va3bZTHLc"
      },
      "outputs": [],
      "source": [
        "#put layers into eval mode (needed for batchnorm especially)\n",
        "for layer in model.layers:\n",
        "  layer.training = False"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true
        },
        "id": "iUodU00RTKCx",
        "outputId": "1e506d03-0750-40f8-b83c-fb9a2b789717"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "train 1.7744334936141968\n",
            "val 1.991883397102356\n"
          ]
        }
      ],
      "source": [
        "# evaluate the loss\n",
        "@torch.no_grad() # this decorator disables gradient tracking inside pytorch\n",
        "def split_loss(split):\n",
        "  x,y = {\n",
        "    'train': (Xtr, Ytr),\n",
        "    'val': (Xdev, Ydev),\n",
        "    'test': (Xte, Yte),\n",
        "  }[split]\n",
        "  logits = model(x)\n",
        "  loss = F.cross_entropy(logits, y)\n",
        "  print(split, loss.item())\n",
        "\n",
        "split_loss('train')\n",
        "split_loss('val')"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true
        },
        "id": "RcdJPI84TNqk",
        "outputId": "b1f9d2b5-eeaf-4552-bd9f-e84844fcdb7e"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "78843\n"
          ]
        }
      ],
      "source": [
        "n_embd = 32 # the dimensionality of the character embedding vectors\n",
        "n_hidden = 128 # the number of neurons in the hidden layer of the MLP\n",
        "model = Sequential([\n",
        "  Embedding(vocab_size, n_embd),\n",
        "  FlattenConsecutive(2), Linear(n_embd * 2, n_hidden, bias=False), BatchNorm1d(n_hidden), RELU(),\n",
        "  FlattenConsecutive(2), Linear(n_hidden*2, n_hidden, bias=False), BatchNorm1d(n_hidden), RELU(),\n",
        "  FlattenConsecutive(2), Linear(n_hidden*2, n_hidden, bias=False), BatchNorm1d(n_hidden), RELU(),\n",
        "  Linear(n_hidden, vocab_size)\n",
        "])\n",
        "\n",
        "# parameter init\n",
        "with torch.no_grad():\n",
        "  model.layers[-1].weight *= 0.1 # last layer make less confident\n",
        "\n",
        "parameters = model.parameters()\n",
        "print(sum(p.nelement() for p in parameters)) # number of parameters in total\n",
        "for p in parameters:\n",
        "  p.requires_grad = True"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true
        },
        "id": "YMepZdtuTR0C",
        "outputId": "b50829bc-75ac-4078-c099-6aebd29c9981"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "      0/ 200000: 3.2949\n",
            "  10000/ 200000: 1.9040\n",
            "  20000/ 200000: 2.3044\n",
            "  30000/ 200000: 2.6934\n",
            "  40000/ 200000: 1.6183\n",
            "  50000/ 200000: 2.1336\n",
            "  60000/ 200000: 1.6200\n",
            "  70000/ 200000: 1.7688\n",
            "  80000/ 200000: 2.0673\n",
            "  90000/ 200000: 1.6819\n",
            " 100000/ 200000: 1.9960\n",
            " 110000/ 200000: 1.5851\n",
            " 120000/ 200000: 2.0257\n",
            " 130000/ 200000: 1.8085\n",
            " 140000/ 200000: 1.7529\n",
            " 150000/ 200000: 1.6393\n",
            " 160000/ 200000: 1.9825\n",
            " 170000/ 200000: 2.0972\n",
            " 180000/ 200000: 1.9419\n",
            " 190000/ 200000: 2.0325\n"
          ]
        }
      ],
      "source": [
        "# same optimization as last time\n",
        "max_steps = 200000\n",
        "batch_size = 32\n",
        "lossi = []\n",
        "\n",
        "for i in range(max_steps):\n",
        "  \n",
        "  # minibatch construct\n",
        "  ix = torch.randint(0, Xtr.shape[0], (batch_size,))\n",
        "  Xb, Yb = Xtr[ix], Ytr[ix] # batch X,Y\n",
        "  \n",
        "  # forward pass\n",
        "  logits = model(Xb)\n",
        "  loss = F.cross_entropy(logits, Yb) # loss function\n",
        "  \n",
        "  # backward pass\n",
        "  for p in parameters:\n",
        "    p.grad = None\n",
        "  loss.backward()\n",
        "  \n",
        "  # update: simple SGD\n",
        "  lr = 0.1 if i < 150000 else 0.01 # step learning rate decay\n",
        "  for p in parameters:\n",
        "    p.data += -lr * p.grad\n",
        "\n",
        "  # track stats\n",
        "  if i % 10000 == 0: # print every once in a while\n",
        "    print(f'{i:7d}/{max_steps:7d}: {loss.item():.4f}')\n",
        "  lossi.append(loss.log10().item())"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "g4l2_d3tTcKL"
      },
      "outputs": [],
      "source": [
        "plt.plot(torch.tensor(lossi).view(-1, 1000).mean(1))"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true
        },
        "id": "Cruff-ymTdoP"
      },
      "outputs": [],
      "source": [
        "# put layers into eval mode (needed for batchnorm especially)\n",
        "for layer in model.layers:\n",
        "  layer.training = False"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true
        },
        "id": "jPOJRBFyTe39",
        "outputId": "4fe03598-f583-43d4-d1af-898b5e54d389"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "train 1.7537466287612915\n",
            "val 1.995898723602295\n"
          ]
        }
      ],
      "source": [
        "# evaluate the loss\n",
        "@torch.no_grad() # this decorator disables gradient tracking inside pytorch\n",
        "def split_loss(split):\n",
        "  x,y = {\n",
        "    'train': (Xtr, Ytr),\n",
        "    'val': (Xdev, Ydev),\n",
        "    'test': (Xte, Yte),\n",
        "  }[split]\n",
        "  logits = model(x)\n",
        "  loss = F.cross_entropy(logits, y)\n",
        "  print(split, loss.item())\n",
        "\n",
        "split_loss('train')\n",
        "split_loss('val')"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "yQdB3cZYbHw0"
      },
      "source": [
        "### performance log\n",
        "\n",
        "- original (3 character context + 200 hidden neurons, 12K params): train 2.058, val 2.105\n",
        "- context: 3 -> 8 (22K params): train 1.918, val 2.027\n",
        "- flat -> hierarchical (22K params): train 1.941, val 2.029\n",
        "- fix bug in batchnorm: train 1.912, val 2.022\n",
        "- scale up the network: n_embd 24, n_hidden 128 (76K params): train 1.769, val 1.993\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true
        },
        "id": "CSE5ZEgebHw0",
        "outputId": "e0a65c1b-556e-4fcf-b81f-a3d5629876ae"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "ightyn.\n",
            "rosam.\n",
            "rii.\n",
            "zulina.\n",
            "irosewe.\n",
            "brithled.\n",
            "jazebella.\n",
            "anex.\n",
            "tismin.\n",
            "kailen.\n",
            "jadiah.\n",
            "adelayde.\n",
            "yayaz.\n",
            "riyan.\n",
            "juleah.\n",
            "ruthie.\n",
            "breydan.\n",
            "davarius.\n",
            "thawal.\n",
            "adystin.\n"
          ]
        }
      ],
      "source": [
        "# sample from the model\n",
        "for _ in range(20):\n",
        "    \n",
        "    out = []\n",
        "    context = [0] * block_size # initialize with all ...\n",
        "    while True:\n",
        "      # forward pass the neural net\n",
        "      logits = model(torch.tensor([context]))\n",
        "      probs = F.softmax(logits, dim=1)\n",
        "      # sample from the distribution\n",
        "      ix = torch.multinomial(probs, num_samples=1).item()\n",
        "      # shift the context window and track the samples\n",
        "      context = context[1:] + [ix]\n",
        "      out.append(ix)\n",
        "      # if we sample the special '.' token, break\n",
        "      if ix == 0:\n",
        "        break\n",
        "    \n",
        "    print(''.join(itos[i] for i in out)) # decode and print the generated word"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "5w054JOpbHw1"
      },
      "source": [
        "### Next time:\n",
        "Why convolutions? Brief preview/hint"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true
        },
        "id": "Qff2A3xcVjcX",
        "outputId": "b109fcd1-a9f0-4c68-a756-614ec57cf2e2"
      },
      "outputs": [
        {
          "data": {
            "text/plain": [
              "tensor([[ 0,  0,  0,  0,  0,  0,  0,  0],\n",
              "        [ 0,  0,  0,  0,  0,  0,  0, 25],\n",
              "        [ 0,  0,  0,  0,  0,  0, 25, 21],\n",
              "        [ 0,  0,  0,  0,  0, 25, 21,  8],\n",
              "        [ 0,  0,  0,  0, 25, 21,  8,  5],\n",
              "        [ 0,  0,  0, 25, 21,  8,  5, 14],\n",
              "        [ 0,  0, 25, 21,  8,  5, 14,  7],\n",
              "        [ 0,  0,  0,  0,  0,  0,  0,  0],\n",
              "        [ 0,  0,  0,  0,  0,  0,  0,  4],\n",
              "        [ 0,  0,  0,  0,  0,  0,  4,  9],\n",
              "        [ 0,  0,  0,  0,  0,  4,  9, 15],\n",
              "        [ 0,  0,  0,  0,  4,  9, 15, 14],\n",
              "        [ 0,  0,  0,  4,  9, 15, 14,  4],\n",
              "        [ 0,  0,  4,  9, 15, 14,  4, 18],\n",
              "        [ 0,  4,  9, 15, 14,  4, 18,  5]])"
            ]
          },
          "execution_count": 41,
          "metadata": {},
          "output_type": "execute_result"
        }
      ],
      "source": [
        "Xtr[0:15]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "colab": {
          "background_save": true
        },
        "id": "zBP4pbSnbHw1",
        "outputId": "cc0ab171-0508-4846-dfb5-c9bef8de67b5"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "........ --> d\n",
            ".......d --> i\n",
            "......di --> o\n",
            ".....dio --> n\n",
            "....dion --> d\n",
            "...diond --> r\n",
            "..diondr --> e\n",
            ".diondre --> .\n"
          ]
        }
      ],
      "source": [
        "for x,y in zip(Xtr[7:15], Ytr[7:15]):\n",
        "  print(''.join(itos[ix.item()] for ix in x), '-->', itos[y.item()])"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "HhUwWXX8bHw2"
      },
      "outputs": [],
      "source": [
        "# forward a single example:\n",
        "logits = model(Xtr[[7]])\n",
        "logits.shape"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "gBDyYGUWbHw2"
      },
      "outputs": [],
      "source": [
        "# forward all of them\n",
        "logits = torch.zeros(8, 27)\n",
        "for i in range(8):\n",
        "  logits[i] = model(Xtr[[7+i]])\n",
        "logits.shape"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "bxPAkE-X_ez5"
      },
      "source": [
        "It looks like a simple RELU perform better than the GELU. I think the problem is GELU will perform better with more training steps."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "PCoo_TvZbHw3"
      },
      "outputs": [],
      "source": [
        "# convolution is a \"for loop\"\n",
        "# allows us to forward Linear layers efficiently over space"
      ]
    }
  ],
  "metadata": {
    "accelerator": "GPU",
    "colab": {
      "provenance": []
    },
    "gpuClass": "standard",
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.8.5"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}